#include "fontrenderer.hpp"
#include <iostream>
#include <boost/spirit.hpp> 
#include <boost/assign/std/vector.hpp>

using namespace boost::assign; // bring 'operator+()' into scope [needed for vector]
using namespace fullcircle;

// test postion for this code
std::vector<int> vars;
int asciiChar;

struct xbmtext_grammar 
: public boost::spirit::grammar<xbmtext_grammar> 
{ 
	/******* these functions are neeeded to store the extracted data **********/
	struct set_asciiChar 
	{ 		
		void operator()(const int d) const 
		{ 
			asciiChar = d;			
		} 
	};
	
	struct number_add {
		void operator()(const int d) const
		{
			vars += d;
		}
	};
	
	struct map_add {
		void operator()(const char *begin, const char *end) const 
		{
			std::cout << asciiChar << " = ";
			for (unsigned int i=0; i < vars.size(); i++) {
				std::cout << vars[i] << " ";
			}
			std::cout << std::endl;
			vars.clear();
		}
	};
	
	
	/******* The real scanning algorithm ************/
	template <typename Scanner> 
	struct definition 
	{ 
		boost::spirit::rule<Scanner> object, value, descval, desckey, description, asciinum, number, image, mapping, string;
		
		definition(const xbmtext_grammar &self) 
		{ 
			
			using namespace boost::spirit; 
			// basic datatypes:
			string = "\"" >> *~ch_p("\"") >> "\"";
			
			mapping = (asciinum >> ":" >> image)[map_add()];
			image = "[" >> number >> *("," >> number) >> "]"; 
			number = int_p[number_add()];
			asciinum = 
			
			(	"\"" >> int_p[set_asciiChar()] >> "\"" )
			;
			desckey = string;
			descval = string;
			description = desckey >> ":" >> descval;
			value = mapping | description;
			object = "{" >> value >> *("," >> value) >> "}"; 
			
		} 
		
		const boost::spirit::rule<Scanner> &start() 
		{ 
			return object; 
		}
		
	}; 
};


FontRenderer::FontRenderer ( uint16_t width, uint16_t height)
  : _width(width)
  , _height(height)
{

};

void FontRenderer::load_font(std::string font_file) {
	/*
	 * This line was generated by:
	 * http://www.pentacom.jp/pentacom/bitfontmaker2/
	 */
	std::string data = "{\"65\":[60,36,60,36,36,0,0,0,0,0,0,0,0,0,0,0],\"66\":[28,36,60,36,28,0,0,0,0,0,0,0,0,0,0,0],\"67\":[60,4,4,4,60,0,0,0,0,0,0,0,0,0,0,0],\"name\":\"\",\"copy\":\"\",\"letterspace\":\"64\"}";
	
	xbmtext_grammar g; 
	boost::spirit::parse_info<> pi = boost::spirit::parse(data.c_str(), g, boost::spirit::space_p); 
	if (pi.hit) 
	{ 
		if (pi.full) 
			std::cout << "parsing all data successfully" << std::endl; 
		else 
			std::cout << "parsing data partially" << std::endl; 
		std::cout << pi.length << " characters parsed" << std::endl;
	} 
	else 
		std::cout << "parsing failed; stopped at '" << pi.stop << "'" << std::endl; 
	//FIXME here is something to do !
}

void FontRenderer::write_text(Sequence::Ptr sequence, uint16_t x, uint16_t y, std::string text) {
	//FIXME here is something to do !
}

