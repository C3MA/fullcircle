/**
 * This file is part of libfullcircle.
 *
 * (c) Mathias Dalheimer <md@gonium.net>, 2012
 *
 * libfullcircle is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * libfullcircle is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with libfullcircle. If not, see <http://www.gnu.org/licenses/>.
 *
 */

#define BOOST_TEST_MODULE fillframe_test
#include <boost/test/unit_test.hpp>
#include <iostream>
#include <fstream>
#include <testconfig.h>
#include <libfullcircle/frame.hpp>
#include <libfullcircle/sequence.hpp>
#include <libfullcircle/sequence.pb.h>
#include <boost/filesystem.hpp>

#include <boost/spirit.hpp> 

namespace bfs=boost::filesystem;

/**
 * see http://www.boost.org/doc/libs/1_43_0/libs/test/doc/html/tutorials/hello-the-testing-world.html
 */

BOOST_AUTO_TEST_CASE ( check_sanity ) {
  try {
    std::cout << "Demo test case: Checking world sanity." << std::endl;
    BOOST_CHECK_EQUAL (42, 42);
    BOOST_CHECK( 23 != 42 );        // #1 continues on error
    BOOST_REQUIRE( 23 != 42 );      // #2 throws on error

  } catch (std::exception const & ex) {
    BOOST_ERROR ( ex.what() );
  }
  if( 23 == 42 ) {
    BOOST_FAIL( "23 == 42, oh noes");             // #4 throws on error
  }
}

struct xbmtext_grammar 
: public boost::spirit::grammar<xbmtext_grammar> 
{ 
	template <typename Scanner> 
	struct definition 
	{ 
		boost::spirit::rule<Scanner> object, value, descval, desckey, description, asciinum, number, image, mapping, string;
		
		definition(const xbmtext_grammar &self) 
		{ 
			using namespace boost::spirit; 
			mapping = asciinum >> ":" >> image;
			image = "[" >> number >> *("," >> number) >> "]"; 
			number = int_p;
			asciinum =  int_p;
			description = "\"" << desckey << "\":\"" << descval << "\"";
			desckey = string;
			descval = string;
			value = mapping | description;
			object = "{" >> value >> *("," >> value) >> "}"; 
			// basic datatypes:
			string = "\"" >> *~ch_p("\"") >> "\"";
		} 
		
		const boost::spirit::rule<Scanner> &start() 
		{ 
			return object; 
		} 
	}; 
}; 


BOOST_AUTO_TEST_CASE ( check_font ) {
	/*
	 * This line was generated by:
	 * http://www.pentacom.jp/pentacom/bitfontmaker2/
	 */
	std::string data = "{\"65\":[60,36,60,36,36,0,0,0,0,0,0,0,0,0,0,0],\"66\":[28,36,60,36,28,0,0,0,0,0,0,0,0,0,0,0],\"67\":[60,4,4,4,60,0,0,0,0,0,0,0,0,0,0,0],\"name\":\"\",\"copy\":\"\",\"letterspace\":\"64\"}";
		
	xbmtext_grammar g; 
	boost::spirit::parse_info<> pi = boost::spirit::parse(data.c_str(), g, boost::spirit::space_p); 
	if (pi.hit) 
	{ 
		if (pi.full) 
			std::cout << "parsing all data successfully" << std::endl; 
		else 
			std::cout << "parsing data partially" << std::endl; 
		std::cout << pi.length << " characters parsed" << std::endl;
	} 
	else 
		std::cout << "parsing failed; stopped at '" << pi.stop << "'" << std::endl; 

}


//BOOST_AUTO_TEST_SUITE_END()
